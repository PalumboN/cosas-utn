(*) Cuando desarrollábamos en Smalltalk, cómo verificábamos que nuestros sistema hacía lo que se pedía? 
Exacto! Con los tests! Y a qué llamamos "test"?
Así es! código que verifica que nuestro código funciona BIEN.



* Testing
	- ¿Por qué testeamos?
		- Somos humanos y nos equivocamos.
		- Queremos asegurar la calidad de nuestro SW.
		- Robustez, consistencia, mantenibilidad.
		- Valor de testear > valor de NO testear.
		- Cobertura de tests.
	- ¿Qué testear?
		- Testear funcionalidades (no accesors).
		- Evitar llegar al debugging:
			- Es una paja.
			- Toma mucho tiempo (repetido por cada error).
			- Fácilmente se pierde el foco.
		- Importancia de la casuística:
			- Armar un buen conjunto de datos.
				- Completitud de los tests.
			- Testear lo que debe y no debe hacer.
			- No testear dos veces la misma cosa.
				- Evitar solapamientos.
	- Tipos de Tests:
		- Granularidad vs Automatización.
			- Integración vs Unitarias.
			- Automatizadas vs Manualse
		- Pruebas de regresión.
		- Teorías vs pruebas tradicionales. [Esto está bueno para Haskell]
	- Anatonía de los tests:
		- Precondiciones: construir el escenario.
			- Simple y específico.
			- Mínima redundancia.
		- Operaciones: hacer lo que se quiere testear.
			- Simple y específico.
			- No romper encapsulamiento.
		- Postcondiciones: resultado esperado.
			- Simple y específico.
			- Abstracciones.
	- Forma parte de la estructura del Sistema:
		- Declaratividad.
		- Expresividad.
		- Evitar lógica repetida.		
	- TDD:
		- Beneficios.
		- Limitaciones.
		